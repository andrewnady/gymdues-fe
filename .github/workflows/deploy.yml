name: Build and Deploy Next.js

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8.15.3

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Type check
        run: pnpm run type-check

      - name: Build application
        run: pnpm run build:production
        env:
          NODE_ENV: production
          NEXT_PUBLIC_API_BASE_URL: https://cms.gymdues.com

      - name: Create deployment package
        run: |
          mkdir -p deploy
          cp -r .next/standalone/. deploy/

          # Copy static assets (standalone excludes these by default)
          mkdir -p deploy/.next/static
          cp -r .next/static/* deploy/.next/static/

          # Copy public folder (images, fonts, etc)
          cp -r public deploy/ 2>/dev/null || true

          # Copy environment variables or create with production values
          if [ -f .env.production ]; then
            cp .env.production deploy/.env
          elif [ -f .env ]; then
            cp .env deploy/.env
          else
            # Create .env file with production values
            echo "NODE_ENV=production" > deploy/.env
            echo "NEXT_PUBLIC_API_BASE_URL=https://cms.gymdues.com" >> deploy/.env
            echo "HOSTNAME=localhost" >> deploy/.env
            echo "PORT=3000" >> deploy/.env
          fi
          
          # Ensure NEXT_PUBLIC_API_BASE_URL is set correctly in .env
          if [ -f deploy/.env ]; then
            # Remove old API URL line if exists
            sed -i.bak '/NEXT_PUBLIC_API_BASE_URL/d' deploy/.env 2>/dev/null || true
            # Add production API URL
            echo "NEXT_PUBLIC_API_BASE_URL=https://cms.gymdues.com" >> deploy/.env
            rm -f deploy/.env.bak 2>/dev/null || true
          fi

          # --------------------------------------------------------
          # VERIFICATION: Ensure BUILD_ID exists before packaging
          # --------------------------------------------------------
          echo "=== Verifying critical files ==="
          if [ ! -f "deploy/.next/BUILD_ID" ]; then
            echo "❌ Error: BUILD_ID is missing in deploy/.next/"
            echo "Listing deploy/.next contents:"
            ls -la deploy/.next/
            exit 1
          else
            echo "✅ BUILD_ID found"
          fi

          # Compress
          tar -czf deploy.tar.gz -C deploy .

      - name: Upload deployment package
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package
          path: deploy.tar.gz
          retention-days: 1

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: success()

    steps:
      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: deployment-package
          path: .

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Add host to known_hosts to avoid interactive prompt
          ssh-keyscan -H ${{ vars.DEPLOY_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to Server
        run: |
          # Upload tarball
          scp -i ~/.ssh/deploy_key deploy.tar.gz ${{ vars.DEPLOY_USER }}@${{ vars.DEPLOY_HOST }}:/tmp/

          # Execute commands on server
          ssh -i ~/.ssh/deploy_key ${{ vars.DEPLOY_USER }}@${{ vars.DEPLOY_HOST }} << 'EOF'
            set -e

            APP_DIR="${{ vars.DEPLOY_PATH }}"
            TEMP_DIR=$(mktemp -d)
            
            echo "Deploying to $APP_DIR..."

            # 1. Extract to temp location
            tar -xzf /tmp/deploy.tar.gz -C "$TEMP_DIR"
            
            # 2. Create destination if not exists
            mkdir -p "$APP_DIR"
            
            # 3. Backup (Optional: Keep one previous version)
            # If server.js exists, move current contents to backup
            # if [ -f "$APP_DIR/server.js" ]; then
            #    rm -rf "$APP_DIR.bak"
            #    cp -r "$APP_DIR" "$APP_DIR.bak"
            # fi

            # 4. Sync files (rsync is safer than cp for overwriting running apps, but cp works)
            # We copy contents of temp dir into app dir
            cp -r "$TEMP_DIR"/* "$APP_DIR/"
            
            # Copy dotfiles (.env, etc)
            cp -r "$TEMP_DIR"/.[!.]* "$APP_DIR/" 2>/dev/null || true

            # 5. Cleanup
            rm -rf "$TEMP_DIR" /tmp/deploy.tar.gz

            # 6. PM2 Process Management
            cd "$APP_DIR"
            
            # Ensure PM2 is installed globally or use npx
            if command -v pm2 &> /dev/null; then
              # Check if process exists
              if pm2 list | grep -q "gymdues-nextjs"; then
                echo "Reloading existing application..."
                pm2 reload gymdues-nextjs --update-env
              else
                echo "Starting new application..."
                # Next.js standalone typically listens on 3000 by default. 
                # PORT and HOSTNAME can be passed here if needed.
                pm2 start server.js --name "gymdues-nextjs"
              fi
              
              # Save PM2 list so it survives reboots
              pm2 save
            else
              echo "Error: PM2 is not installed on the server."
              exit 1
            fi

            echo "Deployment Successful!"
          EOF

      - name: Cleanup SSH Key
        if: always()
        run: rm -f ~/.ssh/deploy_key
