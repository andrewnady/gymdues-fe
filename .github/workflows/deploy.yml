name: Build and Deploy Next.js

on:
  push:
    branches:
      - dev
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8.15.3

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run ESLint
        run: pnpm run lint

      - name: Type check
        run: pnpm run type-check

      - name: Build application
        run: pnpm run build:production
        env:
          NODE_ENV: production

      - name: Create deployment package
        run: |
          mkdir -p deploy
          cp -r .next deploy/
          cp -r public deploy/ 2>/dev/null || true
          cp package.json deploy/
          cp pnpm-lock.yaml deploy/
          cp server.js deploy/ 2>/dev/null || true
          cp next.config.ts deploy/ 2>/dev/null || true
          cp next.config.js deploy/ 2>/dev/null || true
          cp tsconfig.json deploy/ 2>/dev/null || true
          # Copy env file if it exists
          if [ -f .env.production ]; then
            cp .env.production deploy/.env
          elif [ -f .env ]; then
            cp .env deploy/.env
          fi
          tar -czf deploy.tar.gz -C deploy .

      - name: Upload deployment package
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package
          path: deploy.tar.gz
          retention-days: 1

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: success()
    
    steps:
      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: deployment-package
          path: .

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          if [ -z "${{ secrets.DEPLOY_SSH_KEY }}" ]; then
            echo "Error: DEPLOY_SSH_KEY secret is not set"
            exit 1
          fi
          if [ -z "${{ vars.DEPLOY_HOST }}" ]; then
            echo "Error: DEPLOY_HOST variable is not set"
            exit 1
          fi
          if [ -z "${{ vars.DEPLOY_USER }}" ]; then
            echo "Error: DEPLOY_USER variable is not set"
            exit 1
          fi
          if [ -z "${{ vars.DEPLOY_PATH }}" ]; then
            echo "Error: DEPLOY_PATH variable is not set"
            exit 1
          fi
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify key file was created correctly
          if [ ! -f ~/.ssh/deploy_key ]; then
            echo "Error: Failed to create SSH key file"
            exit 1
          fi
          
          # Test SSH connection with verbose output
          ssh-keyscan -H ${{ vars.DEPLOY_HOST }} >> ~/.ssh/known_hosts
          
          # Test SSH connection (dry run)
          echo "Testing SSH connection..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${{ vars.DEPLOY_USER }}@${{ vars.DEPLOY_HOST }} "echo 'SSH connection successful'" || {
            echo "Error: SSH connection test failed"
            echo "Please verify:"
            echo "1. DEPLOY_SSH_KEY contains the complete private key (including BEGIN/END lines)"
            echo "2. Public key is added to ~/.ssh/authorized_keys on the server"
            echo "3. Key permissions are correct (chmod 600)"
            exit 1
          }

      - name: Deploy to DigitalOcean
        run: |
          scp -i ~/.ssh/deploy_key deploy.tar.gz ${{ vars.DEPLOY_USER }}@${{ vars.DEPLOY_HOST }}:/tmp/
          ssh -i ~/.ssh/deploy_key ${{ vars.DEPLOY_USER }}@${{ vars.DEPLOY_HOST }} << 'EOF'
            set -e  # Exit on any error
            DEPLOY_PATH="${{ vars.DEPLOY_PATH }}"
            
            # Create temp directory in user's home (avoid /tmp permission issues)
            TEMP_EXTRACT=$(mktemp -d -p ~)
            
            # Extract to user-owned temp directory
            tar -xzf /tmp/deploy.tar.gz -C "$TEMP_EXTRACT" || {
              echo "Error: Failed to extract deployment package"
              rm -rf "$TEMP_EXTRACT" /tmp/deploy.tar.gz
              exit 1
            }
            
            # Ensure deployment directory exists and is owned by deploy user
            sudo mkdir -p "$DEPLOY_PATH"
            sudo chown -R $USER:$USER "$DEPLOY_PATH"
            
            cd "$DEPLOY_PATH"
            
            # Backup current deployment
            if [ -d ".next" ]; then
              mkdir -p backups
              mv .next backups/.next.backup.$(date +%Y%m%d_%H%M%S) || true
            fi
            
            # Copy files from temp directory
            cp -r "$TEMP_EXTRACT"/* . || {
              echo "Error: Failed to copy deployment files"
              rm -rf "$TEMP_EXTRACT" /tmp/deploy.tar.gz
              exit 1
            }
            
            # Cleanup temp files
            rm -rf "$TEMP_EXTRACT" /tmp/deploy.tar.gz
            
            # Ensure correct permissions
            chmod -R u+w .
            
            # Install only production dependencies
            if command -v pnpm &> /dev/null; then
              pnpm install --prod --frozen-lockfile || pnpm install --prod || {
                echo "Error: Failed to install dependencies"
                exit 1
              }
            else
              npm install --production || {
                echo "Error: Failed to install dependencies"
                exit 1
              }
            fi
            
            # Restart PM2
            pm2 restart gymdues-nextjs || pm2 start npm --name "gymdues-nextjs" -- start || {
              echo "Error: Failed to start/restart PM2 process"
              exit 1
            }
            
            # Verify PM2 process is running
            pm2 list | grep -q "gymdues-nextjs.*online" || {
              echo "Error: PM2 process is not running"
              exit 1
            }
            
            # Cleanup old backups (keep last 3)
            if [ -d "backups" ]; then
              ls -dt backups/.next.backup.* 2>/dev/null | tail -n +4 | xargs rm -rf || true
            fi
            
            echo "Deployment completed successfully"
          EOF

      - name: Cleanup
        if: always()
        run: |
          rm -f deploy.tar.gz
          rm -f ~/.ssh/deploy_key
